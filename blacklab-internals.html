<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.8.1 from src/site/markdown/blacklab-internals.md at 2022-04-13
 | Rendered using Apache Maven Fluido Skin 1.7
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20220413" />
    <meta http-equiv="Content-Language" content="en" />
    <title>BlackLab Core &#x2013; BlackLab internals</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.7.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script type="text/javascript" src="./js/apache-maven-fluido-1.7.min.js"></script>
<link href='http://fonts.googleapis.com/css?family=Nunito:300' rel='stylesheet' type='text/css' />
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <div id="banner">
        <div class="pull-left"><a href="http://www.ivdnt.org/" id="bannerLeft"><img src="images/logo_2_ivd-nt_transparant.png"  alt="Dutch Language Institute (INT)"/></a></div>
        <div class="pull-right"><a href="BlackLab/" id="bannerRight"><img src="images/logo-blacklab.png"  alt="BlackLab"/></a></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
      <li class=""><a href="http://www.ivdnt.org/" class="externalLink" title="INT">INT</a><span class="divider">/</span></li>
      <li class=""><a href="index.html" title="BlackLab">BlackLab</a><span class="divider">/</span></li>
    <li class="active ">BlackLab internals</li>
        <li id="publishDate" class="pull-right"><span class="divider">|</span> Last Published: 2022-04-13</li>
          <li id="projectVersion" class="pull-right">Version: 2.3.0</li>
        </ul>
      </div>
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
    <ul class="nav nav-list">
      <li class="nav-header">BlackLab</li>
    <li><a href="index.html" title="Introduction"><span class="none"></span>Introduction</a></li>
    <li><a href="learn.html" title="Learn"><span class="icon-chevron-down"></span>Learn</a>
    <ul class="nav nav-list">
    <li><a href="getting-started.html" title="Getting Started"><span class="none"></span>Getting Started</a></li>
    <li><a href="corpus-query-language.html" title="Corpus Query Language"><span class="none"></span>Corpus Query Language</a></li>
    <li><a href="blacklab-server-overview.html" title="BlackLab Server overview"><span class="none"></span>BlackLab Server overview</a></li>
    <li><a href="configuration-files.html" title="Configuration files"><span class="none"></span>Configuration files</a></li>
    <li><a href="blacklab-server-different-languages.html" title="Using BlackLab Server from different languages"><span class="none"></span>Using BlackLab Server from different languages</a></li>
    <li><a href="indexing-with-blacklab.html" title="Indexing with BlackLab"><span class="none"></span>Indexing with BlackLab</a></li>
    <li><a href="add-input-format.html" title="Add An Input Format"><span class="none"></span>Add An Input Format</a></li>
    <li><a href="improve-search-speed.html" title="Improve Search Speed"><span class="none"></span>Improve Search Speed</a></li>
    <li><a href="apidocs/index.html" title="API reference"><span class="none"></span>API reference</a></li>
    <li><a href="file-formats.html" title="File formats"><span class="none"></span>File formats</a></li>
    </ul>
</li>
    <li><a href="downloads.html" title="Downloads"><span class="none"></span>Downloads</a></li>
    <li><a href="faq.html" title="FAQ"><span class="none"></span>FAQ</a></li>
    <li><a href="changelog.html" title="Change Log"><span class="none"></span>Change Log</a></li>
    <li><a href="roadmap.html" title="Road Map"><span class="none"></span>Road Map</a></li>
    <li><a href="newsletter.html" title="Newsletter"><span class="none"></span>Newsletter</a></li>
      <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
</ul>
          <hr />
          <div id="poweredBy">
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </div>
        <div id="bodyColumn"  class="span10" >
<h1>BlackLab internals</h1>
<p>Here we want to document how BlackLab works internally. At the moment it is still very much incomplete, but we intend to add and update information as time goes on.</p>
<div class="section">
<h2><a name="BlackLab_technical_overview"></a>BlackLab technical overview</h2>
<p>The basis of a BlackLab index is the Lucene index. The Lucene files are all found in the main index directory. Lucene provides the reverse index part of BlackLab, that is, it can quickly locate in what documents and at what positions certain word(s) or constructs appear.</p>
<p>You can identify a BlackLab index by the <tt>version.dat</tt> file in the main index directory. This file should always contain the text <tt>blacklab||2</tt>.</p>
<p>What BlackLab adds to the Lucene index are a <i>content store</i> and <i>forward indexes</i>.</p>
<div class="section">
<h3><a name="content_store"></a>content store</h3>
<p>The content store is the simplest to explain: it stores the original (e.g. XML) documents you added to BlackLab. The documents can be retrieved from the content store if you want to display them (e.g. using XSLT). Matches may be highlighted in the document.</p>
<p>It is also possible to retrieve snippets from the original document (XML is carefully kept wellformed), and even to generate the keyword-in-context (KWIC) view using the original content (normally the KWIC view is generated using the forward index, which is faster but doesn&#x2019;t preserve the original tag structure, e.g. sentence tags, named entity tags, etc.)</p>
<p>In the future, we may want to make the content store optional, because users often have these documents available from another source, such as a webservice. The challenge in this case is to keep highlighting efficient (BlackLab stores its content such that the position information it gets from Lucene can be used directly to highlight the document).</p>
<p>The content store is found in the subdirectory <tt>cs_contents</tt> (at least, if your annotated field is named <tt>contents</tt>; you could even have multiple annotated fields). The content store subdirectory has its own <tt>version.dat</tt>, which should contain <tt>fixedblock||1</tt>.</p></div>
<div class="section">
<h3><a name="forward_index"></a>forward index</h3>
<p>Each of your annotations can have a forward index. A forward index is a structure that can quickly answer questions of the form &#x201c;what annotation values occur in document 123 at positions 20 &#x2026; 24?&#x201d;</p>
<div class="section">
<h4><a name="How_the_forward_index_is_used"></a>How the forward index is used</h4>
<p>The forward index is used to speed up sorting and grouping hits by context. For example, sorting hits by their &#x201c;lemma&#x201d; annotation, or grouping them by their &#x201c;pos&#x201d; (part of speech) annotation. Without the forward index, we would have to retrieve the original input file, get XML snippet corresponding with our match, and parse it to get the annotation values. Needless to say this would be way too slow.</p>
<p>The forward index is also used to resolve &#x201c;global constraints&#x201d;, such as in a Corpus Query like <tt>A:[] &quot;and&quot; B:[] :: A.word = B.word</tt>. The global constraint is the part after <tt>::</tt>, and it is used to filter hits found using the part before <tt>::</tt>.</p>
<p>Finally, the forward index can be used to speed up certain searches that would be slow using Lucene&#x2019;s index. For example, in a very large index (say more than a 1G (billion) words), regex clauses can be very slow. A query like <tt>&quot;.*e&quot; &quot;ship&quot;</tt> (a word ending in <i>e</i> followed by the word <i>ship</i>) would take a very long time finding all terms that end in <i>e</i> and then finding all matches for those terms. Instead we use Lucene&#x2019;s reverse index to find all occurrences of <i>ship</i>, then use the forward index to check if the preceding word ends in <tt>&quot;.e&quot;</tt>. Another way of putting it is to say we rewrite the query to convert the problematic clause to a global constraint, so the query becomes <tt>A:[] &quot;ship&quot; :: A.word = &quot;.*e&quot;&quot;</tt> (even though this is not what happens internally).</p>
<p>Forward index matching is also called NFA matching in the code, because it uses a nondeterministic finite automaton to evaluate queries against the forward index.</p>
<p>While it can make certain queries faster, deciding whether or not to use the forward index does take a bit of time (many possibilities are tried and term frequencies are looked up; see <tt>ClauseCombinerNfa</tt>). For scenarios with small indexes and many queries per second, this functionality may hurt rather than help. If you want to disable forward-index matching , you can set <tt>search.fiMatchFactor</tt> to <tt>0</tt> in <tt>blacklab-server.yml</tt>.</p></div>
<div class="section">
<h4><a name="Structure_of_the_forward_index"></a>Structure of the forward index</h4>
<p>The combined forward indexes also contain most of the contents of the documents, but missing are the tags around an in between the words (bold and italic tags, paragraph and sentence tags, header and body tags, metadata tags, etc.).</p>
<p>All annotations get a forward index by default, but you can <a href="how-to-configure-indexing.md#disable-fi">disable this if you want</a>.</p>
<p>Each annotation has its own forward index directory. These directories are named <tt>fi_contents%word</tt>, <tt>fi_contents%word</tt>, etc. (again, assuming your annotated field is <tt>contents</tt>). The <tt>version.dat</tt> file in each forward index directory should contain either <tt>fi||4</tt> or <tt>fi||5</tt>. (these versions differ only in the collators used for sorting terms)</p>
<p>For more in-depth information about the layout of the non-Lucene files in a BlackLab index, see <a href="file-formats.md">File formats for the forward index and content store</a>.</p></div></div>
<div class="section">
<h3><a name="index_metadata_file"></a>index metadata file</h3>
<p>Each index has a file called <tt>indexmetadata.yaml</tt>. This file contains information that BlackLab needs, such as:</p>
<ul>

<li>total number of tokens</li>
<li>pid field</li>
<li>analyzers used for metadata fields</li>
<li>whether or not the full content of a document may be retrieved</li>
<li>metadata field type (tokenized, untokenized, text, numeric)</li>
</ul>
<p>It also contains extra information that may be useful for applications using BlackLab, such as the &#x201c;official&#x201d; <a class="externalLink" href="https://gibhub.com/INL/corpus-frontend">corpus-frontend</a>:</p>
<ul>

<li>name and description of the index and its fields</li>
<li>document format name</li>
<li>metadata fields containing title, author, date</li>
<li>version info</li>
<li>text direction, LTR or RTL</li>
<li>how missing metadata fields were handled during indexing (<tt>unknownValue</tt>, <tt>unknownCondition</tt>)</li>
<li>metadata field values, display values</li>
<li>display order for metadata and annotated fields</li>
<li>how metadata fields should logically be grouped</li>
</ul>
<p>It could be argued that the second group of properties don&#x2019;t really belong in BlackLab and should perhaps be moved to the application using BlackLab. This might be the direction we take in the future. We estimate that beside our own corpus-frontend, not many other applications use these properties.</p>
<p>A complete, documented example of <tt>indexmetadata.yaml</tt> can be found <a href="indexing-with-blacklab.md#edit-index-metadata">here</a>.</p></div>
<div class="section">
<h3><a name="Files_needed_for_indexing"></a>Files needed for indexing</h3>
<p>TODO</p>
<p>index configuration file (<tt>.blf.yaml</tt>) / DocIndexer</p>
<p>A complete, documented example of an input format configuration file can be found <a href="how-to-configure-indexing.md#annotated-input-format-configuration-file">here</a>.</p></div>
<div class="section">
<h3><a name="Performance_optimizations"></a>Performance optimizations</h3>
<p>BlackLab tries to find the most efficient way to execute a query. This is done when a <tt>BLSpanQuery</tt> is about to be executed. Lucene&#x2019;s <tt>SpanQuery</tt> class has a <tt>rewrite</tt> method that rewrites the query if needed (e.g. SpanRegexQuery will rewrite to SpanBooleanQuery+SpanTermQuery, effectively OR&#x2019;ing SpanTermQueries for all matching terms). <tt>BLSpanQuery</tt> adds an <tt>optimize</tt> method that is run first. <tt>optimize()</tt> is only implemented by <tt>SpanQuerySequence</tt> for now. Here we look at high-level optimizations that should be tried before the &#x201c;normal&#x201d; rewrite process.</p>
<p>These include:</p>
<ul>

<li>flattening nested queries e.g. <tt>&quot;the&quot; (&quot;quick&quot; (&quot;brown&quot;)) &quot;fox&quot;</tt> to <tt>&quot;the&quot; &quot;quick&quot; &quot;brown&quot; &quot;fox&quot;</tt></li>
<li>recognizing a <tt>containing</tt> search like <tt>&lt;s&gt; []* &quot;lazy&quot; &quot;dog&quot; []* &lt;/s&gt;</tt> to <tt>&lt;s/&gt; containing &quot;lazy&quot; &quot;dog&quot;</tt></li>
<li>combining adjacent clauses (applying possible <tt>ClauseCombiner</tt> operations from highest-scoring to lowest-scoring)</li>
</ul>
<p><tt>ClauseCombiner</tt> operations include:</p>
<ul>

<li>&#x201c;internalization&#x201d; (making longer sequences that are better for optimization, but might need the resulting hit start/end to be adjusted, e.g. &#x201c;[] x:A&#x201d; to &#x201c;x:([] A)&#x201d;, but with the start of x adjusted by +1)</li>
<li>&#x201c;anytoken expansion&#x201d;, i.e. making sure queries like <tt>[] &quot;fox&quot;</tt> are not resolved by finding all tokens in the corpus, then combining them with <i>fox</i>, but by finding <i>fox</i> and adjusting the hit starts by -1.</li>
<li>&#x201c;nfa&#x201d;: forward index matching, as discussed before</li>
<li>&#x201c;not containing&#x201d;: converting <tt>[word != &quot;red&quot;] &quot;fox&quot;</tt> to <tt>([] &quot;fox&quot;) notcontaining &quot;red&quot;</tt> if possible (instead of finding all tokens that are not <i>red</i>)</li>
<li>&#x201c;repetition&#x201d;: converting <tt>&quot;jump&quot; &quot;jump&quot; &quot;jump&quot;</tt> to <tt>&quot;jump&quot;{3}</tt>, which is faster to process</li>
</ul>
<p>To help choose the best possible optimizations, <tt>BLSpanQuery</tt> contains a number of &#x201c;guarantee methods&#x201d;:</p>
<ul>

<li><tt>okayToInvertForOptimization</tt>: is this a suitable clause to invert if that helps us optimize? (e.g. <tt>[word != &quot;red&quot;]</tt> would be suitable, but <tt>[lemma = &quot;fox&quot;]</tt> would not)</li>
<li><tt>isSingleTokenNot</tt>: is this a negative query that matches a single token such as <tt>[word != &quot;red&quot;]</tt></li>
<li><tt>producesSingleTokens</tt>: does this query produce only hits of length 1?</li>
<li><tt>hitsAllSameLength</tt>: does this query produce hits that are all the same length?</li>
<li>&#x2026;etc.</li>
</ul>
<p>Besides deciding what optimization to apply, these methods also help us decide if a query can produce duplicate matches (which should be filtered out later) and if a query can produce matches that are not sorted by match starting position (which should be re-sorted later). For example (e.g. <tt>[]{1,3} &quot;ship&quot;</tt> will produce a SpanQueryExpansion to expand hits for <i>ship</i> to the left by 1-3 tokens, but the resulting matches are not guaranteed to be sorted by starting position, so the hits could be something like 0-3, 1-3, 2-3, 1-4, 2-4, 3-4, etc.</p></div></div>
<div class="section">
<h2><a name="Module_structure"></a>Module structure</h2>
<p>BlackLab has been divided up into modules that serve specific functions. This is intended to make the structure and dependencies clearer, to make BlackLab easier to understand and make future improvements easier.</p>
<p>This the current list of modules:</p>
<table border="0" class="table table-striped">
<thead>

<tr class="a">
<th> Module          </th>
<th> Description                                                  </th></tr>
</thead><tbody>

<tr class="b">
<td> <tt>common</tt>          </td>
<td> classes used by a number of other modules. Currently only contains BlackLab-specific <tt>Exception</tt> subclasses.</td></tr>
<tr class="a">
<td> <tt>content-store</tt>   </td>
<td> responsible for storing the input documents indexed in BlackLab for later display with optional highlighting of hits. </td></tr>
<tr class="b">
<td> <tt>contrib/*</tt>       </td>
<td> some modules that serve specific functions that some projects may need, but many don&#x2019;t. Currently contains plugins to convert and tag input documents before indexing, as well as some legacy <tt>DocIndexer</tt> implementations. </td></tr>
<tr class="a">
<td> <tt>core</tt>            </td>
<td> will build the main BlackLab Java library. Doesn&#x2019;t contain any Java code itself but combines other modules (the main module is engine). </td></tr>
<tr class="b">
<td> <tt>engine</tt>          </td>
<td> implements most of the BlackLab functionality. </td></tr>
<tr class="a">
<td> <tt>instrumentation</tt> </td>
<td> two experimental modules for monitoring BlackLab Server using Prometheus or similar. </td></tr>
<tr class="b">
<td> <tt>mocks</tt>           </td>
<td> mock objects useful for testing. Shouldn&#x2019;t be included in library build. </td></tr>
<tr class="a">
<td> <tt>query-parser</tt>    </td>
<td> the main Corpus Query Language parser (as well the more limited Contextual Query Language parser). </td></tr>
<tr class="b">
<td> <tt>server</tt>          </td>
<td> the BlackLab Server web service </td></tr>
<tr class="a">
<td> <tt>text-pattern</tt>    </td>
<td> the <tt>TextPattern</tt> classes that currently sit between the query parser and the <tt>SpanQuery</tt> classes. </td></tr>
</tbody>
</table>
<p>Future plans for this module structure:</p>
<ul>

<li><tt>common</tt> should probably not grow; rather shrink and ideally be eliminated altogether</li>
<li><tt>content-store</tt> should be made optional, so you can also use e.g. an external webservice to retrieve the document contents.</li>
<li><tt>engine</tt> currently does a lot, with a lot of interdependencies between classes, and could/should therefore be divided up into logical modules.</li>
<li><tt>query-parser</tt> could be reduced to just the Corpus Query Language parser, with the Contextual Query Language parser moved into a <tt>contrib</tt> module.</li>
<li><tt>text-pattern</tt> could eventually become unnecessary as we move their functionality into the various <tt>SpanQuery</tt> classes, and could then be moved to <tt>contrib</tt> for legacy uses.</li>
</ul></div>
<div class="section">
<h2><a name="Important_classes_and_their_function"></a>Important classes and their function</h2>
<div class="section">
<h3><a name="Engine.2C_index"></a>Engine, index</h3>
<ul>

<li><tt>BlackLabEngine</tt> is the class that manages the BlackLab search threads. It has a <tt>searchExecutorService</tt> that search threads can be submitted to. The <tt>open</tt> and <tt>openForWriting</tt> methods can be used to open indexes.</li>
<li><tt>BlackLabIndex</tt> represents a single opened index. You can use it to search the index directly using methods like <tt>find(BLSpanQuery)</tt>, or you can construct a <tt>Search</tt> description using the <tt>search()</tt> methods and then either execute it synchronously using <tt>Search.execute()</tt> or go through the cache using <tt>Search.executeAsync()</tt>.</li>
</ul></div>
<div class="section">
<h3><a name="Search_results"></a>Search results</h3>
<ul>

<li><tt>SearchResult</tt> is the base interface that all types of results objects implement: <tt>Hits</tt> (and its subclasses like <tt>HitsFromQueryParallel</tt>), <tt>HitGroups</tt>, <tt>DocResults</tt>, <tt>Facets</tt>, etc.</li>
</ul></div>
<div class="section">
<h3><a name="Search_cache"></a>Search cache</h3>
<p>BlackLab features a cache system that can keep track of results of finished queries as well as currently running queries.</p>
<p>The idea is that users will often search for something that can benefit from having recent query results available. For example: paging back and forth through a result set; changing the sort for a result set; grouping a result set by some criterium.</p>
<p>The potential disadvantage of such a cache is that it can take up a lot of memory, starving other queries of memory.</p>
<p>The implementation of the cache is left up to the user of BlackLab. BlackLab Server, the webservice accompanying BlackLab, provides an implementation that can be configured in various ways (see <tt>BlsCache</tt> below).</p>
<div class="section">
<h4><a name="BlackLab_caching"></a>BlackLab caching</h4>
<p>These are the important interfaces and classes involved in BlackLab&#x2019;s cache system and BLS&#x2019;s implementation:</p>
<ul>

<li><tt>Search&lt;R extends SearchResult&gt;</tt> and its subclasses can be used to build complete descriptions of search requests (e.g. a query for hits, with optional sorting, grouping, etc.). It has <tt>execute()</tt> and <tt>executeAsync()</tt> methods that execute the search task described by the &#x201c;tree&#x201d; of <tt>Search</tt>es. The different classes rely on each other&#x2019;s functionality, so <tt>SearchHitsSorted</tt> gets a <tt>SearchHits</tt> as a parameter and will call its <tt>execute</tt> method before sorting the hits produced by that. <tt>Search&lt;R&gt;.executeAsync()</tt> calls <tt>SearchCache.getAsync(this)</tt>, which will return a <tt>SearchCacheEntry&lt;R extends SearchResult&gt;</tt> that either has already completed (i.e. the results are actually in the cache from before) or will be executed and produce its results when the <tt>SearchCacheEntry</tt> (a <tt>Future</tt>) completes (i.e. wasn&#x2019;t in the cache but is now and is being or will be executed).</li>
<li><tt>SearchCache</tt> is the interface that cache implementations must adhere to. Its main two methods are <tt>get()</tt> and <tt>getAsync()</tt>, which take a search (subclass of <tt>Search&lt;R extends SearchResult&gt;</tt>, where <tt>R</tt> is the type of <tt>SearchResult</tt> we expect from the search). <tt>get()</tt> will block until the result is available (either found in the cache or executed). <tt>getAsync()</tt> will not block but return a <tt>SearchCacheEntry&lt;R&gt;</tt>, that will eventually yield the desired results. The cache itself stores these <tt>SearchCacheEntry</tt>s, so you can retrieve the &#x201c;results&#x201d; of an ongoing search.</li>
</ul>
<p>NOTE: <tt>BlackLabEngine</tt>&#x2019;s <tt>searchExecutorService</tt> uses a standard <tt>Executors.newCachedThreadPool()</tt>. It has no maximum number of threads. Instead we limit the maximum number of <tt>BlsCacheEntry</tt>s that can be running at any one time. New <tt>BlsCacheEntry</tt>s submitted when we&#x2019;re already at the maximum number of running entries will be waiting to start (queued) until they can be executed. Note that only top-level searches (i.e. those requested by the user) can be queued; others will be started automatically right away. For example, if the user requests hits for <tt>cat</tt> grouped by metadata field <tt>author</tt>, that entire request may be queued. But when it is unqueued (i.e. started), both the hits request and the grouping of those hits are allowed to run. This way of queueing was chosen to prevent deadlocks when a required intermediate result is not available because it is queued and cannot be started until the waiting thread has finished.</p>
<p>NOTE: unless a custom <tt>SearchCache</tt> is configured (like BlackLab Server does), BlackLab uses a dummy cache that doesn&#x2019;t actually cache anything. So <tt>executeAsync()</tt> will block and return an already-completed <tt>SearchCacheEntry</tt>, effectively doing the same as <tt>execute()</tt>.</p></div>
<div class="section">
<h4><a name="BLS_cache_implementation"></a>BLS cache implementation</h4>
<p>BlackLab Server implements a custom cache to improve performance for users who might be paging through results, re-ordering results, going from hits to grouped hits, etc.</p>
<p>This works as follows:</p>
<ul>

<li><tt>BlsCache</tt> implements <tt>SearchCache</tt> that manages the cache based on the amount of free Java heap memory to strive for, how long a search has been running, how long since results have been accessed, etc. See the configuration of BlackLab Server for details.</li>
<li><tt>BlsCacheEntry&lt;T extends SearchResult&gt;</tt> represents an entry in the cache. As <tt>SearchCache</tt> requires, it implements <tt>SearchCacheEntry&lt;T extends SearchResult&gt;</tt>. It is returned from <tt>BlsCache.getAsync()</tt>.</li>
<li><tt>BlsCacheEntry</tt> submits a <tt>Runnable</tt> to <tt>BlackLabEngine</tt>&#x2019;s <tt>searchExecutorService</tt>.</li>
<li><tt>SpansReader</tt> is also a <tt>Runnable</tt> that is submitted to <tt>BlackLabEngine</tt>&#x2019;s <tt>searchExecutorService</tt>. Note that because <tt>SpansReader</tt> is not a <tt>BlsCacheEntry</tt>, we don&#x2019;t actually keep track of these as running searches for load management. It would be better to do this.</li>
</ul></div></div></div>
        </div>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &copy;2022
<a href="https://www.ivdnt.org/">Instituut voor Nederlandse Taal (INT)</a>.
All rights reserved.</p>
        </div>
      </div>
    </footer>
  </body>
</html>
