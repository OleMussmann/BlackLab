<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.8.1 from src/site/markdown/corpus-query-language.md at 2022-04-13
 | Rendered using Apache Maven Fluido Skin 1.7
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20220413" />
    <meta http-equiv="Content-Language" content="en" />
    <title>BlackLab Core &#x2013; Corpus Query Language</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.7.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script type="text/javascript" src="./js/apache-maven-fluido-1.7.min.js"></script>
<link href='http://fonts.googleapis.com/css?family=Nunito:300' rel='stylesheet' type='text/css' />
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <div id="banner">
        <div class="pull-left"><a href="http://www.ivdnt.org/" id="bannerLeft"><img src="images/logo_2_ivd-nt_transparant.png"  alt="Dutch Language Institute (INT)"/></a></div>
        <div class="pull-right"><a href="BlackLab/" id="bannerRight"><img src="images/logo-blacklab.png"  alt="BlackLab"/></a></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
      <li class=""><a href="http://www.ivdnt.org/" class="externalLink" title="INT">INT</a><span class="divider">/</span></li>
      <li class=""><a href="index.html" title="BlackLab">BlackLab</a><span class="divider">/</span></li>
    <li class="active ">Corpus Query Language</li>
        <li id="publishDate" class="pull-right"><span class="divider">|</span> Last Published: 2022-04-13</li>
          <li id="projectVersion" class="pull-right">Version: 2.3.0</li>
        </ul>
      </div>
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
    <ul class="nav nav-list">
      <li class="nav-header">BlackLab</li>
    <li><a href="index.html" title="Introduction"><span class="none"></span>Introduction</a></li>
    <li><a href="learn.html" title="Learn"><span class="icon-chevron-down"></span>Learn</a>
    <ul class="nav nav-list">
    <li><a href="getting-started.html" title="Getting Started"><span class="none"></span>Getting Started</a></li>
    <li class="active"><a href="#"><span class="none"></span>Corpus Query Language</a></li>
    <li><a href="blacklab-server-overview.html" title="BlackLab Server overview"><span class="none"></span>BlackLab Server overview</a></li>
    <li><a href="configuration-files.html" title="Configuration files"><span class="none"></span>Configuration files</a></li>
    <li><a href="blacklab-server-different-languages.html" title="Using BlackLab Server from different languages"><span class="none"></span>Using BlackLab Server from different languages</a></li>
    <li><a href="indexing-with-blacklab.html" title="Indexing with BlackLab"><span class="none"></span>Indexing with BlackLab</a></li>
    <li><a href="add-input-format.html" title="Add An Input Format"><span class="none"></span>Add An Input Format</a></li>
    <li><a href="improve-search-speed.html" title="Improve Search Speed"><span class="none"></span>Improve Search Speed</a></li>
    <li><a href="apidocs/index.html" title="API reference"><span class="none"></span>API reference</a></li>
    <li><a href="file-formats.html" title="File formats"><span class="none"></span>File formats</a></li>
    </ul>
</li>
    <li><a href="downloads.html" title="Downloads"><span class="none"></span>Downloads</a></li>
    <li><a href="faq.html" title="FAQ"><span class="none"></span>FAQ</a></li>
    <li><a href="changelog.html" title="Change Log"><span class="none"></span>Change Log</a></li>
    <li><a href="roadmap.html" title="Road Map"><span class="none"></span>Road Map</a></li>
    <li><a href="newsletter.html" title="Newsletter"><span class="none"></span>Newsletter</a></li>
      <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
</ul>
          <hr />
          <div id="poweredBy">
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </div>
        <div id="bodyColumn"  class="span10" >
<h1>Corpus Query Language</h1>
<p>BlackLab supports Corpus Query Language, a full-featured query language introduced by the IMS Corpus WorkBench (CWB) and also supported by the Lexicom Sketch Engine. It is a standard and powerful way of searching corpora.</p>
<p>The basics of Corpus Query Language is the same in all three projects, but in there are a few minor differences in some of the more advanced features, as well as some features that are exclusive to some projects. For most queries however, this will not be an issue.</p>
<p>This page will introduce the query language and show all features that BlackLab supports. If you want to learn even more about CQL, see <a class="externalLink" href="http://cwb.sourceforge.net/files/CQP_Tutorial/" title="http://cwb.sourceforge.net/files/CQP_Tutorial/">CWB CQP Query Language Tutorial</a> and <a class="externalLink" href="https://www.sketchengine.co.uk/documentation/corpus-querying/" title="https://www.sketchengine.co.uk/documentation/corpus-querying/">Sketch Engine Corpus Query Language</a>.</p>
<ul>

<li><a href="#cql-support">CQL support</a>
<ul>

<li><a href="#supported-features">Supported features</a></li>
<li><a href="#differences-cwb">Differences from CWB</a></li>
<li><a href="#unsupported">(Currently) unsupported features</a></li>
</ul>
</li>
<li><a href="#using-cql">Using Corpus Query Language</a>
<ul>

<li><a href="#matching-tokens">Matching tokens</a></li>
<li><a href="#sequences">Sequences</a></li>
<li><a href="#regex-operators-tokens">Regular expression operators on tokens</a></li>
<li><a href="#case-diacritics-sensitivity">Case- and diacritics-sensitivity</a></li>
<li><a href="#matching-xml-elements">Matching XML elements</a></li>
<li><a href="#label-tokens-capturing-groups">Labels, capturing groups</a></li>
<li><a href="#global-constraints">Global constraints</a></li>
</ul>
</li>
</ul>
<p><a name="cql-support" id="cql-support"></a></p>
<div class="section">
<h2><a name="CQL_support"></a>CQL support</h2>
<p>For those who already know CQL, here&#x2019;s a quick overview of the extent of BlackLab&#x2019;s support for this query language. If you a feature we don&#x2019;t support yet is important to you, please let us know. If it&#x2019;s quick to add, we may be able to help you out.</p>
<p><a name="supported-features" id="supported-features"></a></p>
<div class="section">
<h3><a name="Supported_features"></a>Supported features</h3>
<p>BlackLab currently supports (arguably) most of the important features of Corpus Query Language:</p>
<ul>

<li>Matching on token annotations (also called properties or attributes), using regular expressions and <tt>=</tt>, <tt>!=</tt>, <tt>!</tt>. Example: <tt>[word=&quot;bank&quot;]</tt> (or just <tt>&quot;bank&quot;</tt>)</li>
<li>Case/accent sensitive matching. Note that, unlike in CWB, case-INsensitive matching is currently the default. To explicitly match case-/accent-insensitively, use <tt>&quot;(?i)...&quot;</tt>. Example: <tt>&quot;(?-i)Mr\.&quot; &quot;(?-i)Banks&quot;</tt></li>
<li>Combining criteria using <tt>&amp;</tt>, <tt>|</tt> and <tt>!</tt>. Parentheses can also be used for grouping. Example: <tt>[lemma=&quot;bank&quot; &amp; pos=&quot;V&quot;]</tt></li>
<li>Matchall pattern <tt>[]</tt> matches any token. Example: <tt>&quot;a&quot; [] &quot;day&quot;</tt></li>
<li>Regular expression operators <tt>+</tt>, <tt>*</tt>, <tt>?</tt>, <tt>{n}</tt>, <tt>{n,m}</tt> at the token level. Example: <tt>[pos=&quot;ADJ&quot;]+</tt></li>
<li>Sequences of token constraints. Example: <tt>[pos=&quot;ADJ&quot;] &quot;cow&quot;</tt></li>
<li>Operators <tt>|</tt>, <tt>&amp;</tt> and parentheses can be used to build complex sequence queries. Example: <tt>&quot;happy&quot; &quot;dog&quot; | &quot;sad&quot; cat&quot;</tt></li>
<li>Querying with tag positions using e.g. <tt>&lt;s&gt;</tt> (start of sentence), <tt>&lt;/s&gt;</tt> (end of sentence), <tt>&lt;s/&gt;</tt> (whole sentence) or <tt>&lt;s&gt; ... &lt;/s&gt;</tt> (equivalent to <tt>&lt;s/&gt; containing ...</tt>). Example: <tt>&lt;s&gt; &quot;The&quot;</tt>. XML attribute values may be used as well, e.g. <tt>&lt;ne type=&quot;PERS&quot;/&gt;</tt> (&#x201c;named entities that are persons&#x201d;).</li>
<li>Using <tt>within</tt> and <tt>containing</tt> operators to find hits inside another set of hits. Example: <tt>&quot;you&quot; &quot;are&quot; within &lt;s/&gt;</tt></li>
<li>Using an anchor to capture a token position. Example: <tt>&quot;big&quot; A:[]</tt>. Captured matches can be used in global constraints (see next item) or processed separately later (using the Java interface; capture information is not yet returned by BlackLab Server). Note that BlackLab can actually capture entire groups of tokens as well, similarly to regular expression engines.</li>
<li>Global constraints on captured tokens, such as requiring them to contain the same word. Example: <tt>&quot;big&quot; A:[] &quot;or&quot; &quot;small&quot; B:[] :: A.word = B.word</tt></li>
</ul>
<p>See below for features not in this list that may be added soon, and let us know if you want a particular feature to be added.</p>
<p><a name="differences-cwb" id="differences-cwb"></a></p></div>
<div class="section">
<h3><a name="Differences_from_CWB"></a>Differences from CWB</h3>
<p>BlackLab&#x2019;s CQL syntax and behaviour differs in a few small ways from CWBs. In future, we&#x2019;ll aim towards greater compliance with CWB&#x2019;s de-facto standard (with some extra features and conveniences).</p>
<p>For now, here&#x2019;s what you should know:</p>
<ul>

<li>Case-insensitive search is currently the default in BlackLab, although you can change this if you wish. CWB and Sketch Engine use case-sensitive search as the default. We may change our default in a future major version.<br />
If you want to switch case/diacritics sensitivity, use <tt>&quot;(?-i)..&quot;</tt> (case sensitive) or <tt>&quot;(?i)..&quot;</tt> (case insensitive, usually the default). CWBs <tt>%cd</tt> flags for setting case/diacritics-sensitivity are not (yet) supported, but will be added.</li>
<li>If you want to match a string literally, not as a regular expression, use backslash escaping: <tt>&quot;e\.g\.&quot;</tt>. <tt>%l</tt> for literal matching is not yet supported, but will be added.</li>
<li>BlackLab supports result set manipulation such as: sorting (including on specific context words), grouping/frequency distribution, subsets, sampling, setting context size, etc. However, these are supported through the REST and Java APIs, not through a command interface like in CWB. See <a href="blacklab-server-overview.html">BlackLab Server overview</a>).</li>
<li>Querying XML elements and attributes looks natural in BlackLab: <tt>&lt;s/&gt;</tt> means &#x201c;sentences&#x201d;, <tt>&lt;s&gt;</tt> means &#x201c;starts of sentences&#x201d;, <tt>&lt;s type='A'&gt;</tt> means &#x201c;sentence tags with a type attribute with value A&#x201d;. This natural syntax differs from CWBs in some places, however, particularly when matching XML attributes. While we believe our syntax is the superior one, we may add support for the CWB syntax as an alternative.<br />
We only support literal matching of XML attributes at the moment, but this will be expanded to full regex matching.</li>
<li>In global constraints (expressions occurring after <tt>::</tt>), only literal matching (no regex matching) is currently supported. Regex matching will be added soon. For now, instead of <tt>A:[] &quot;dog&quot; :: A.word = &quot;happy|sad&quot;</tt>, use <tt>&quot;happy|sad&quot; &quot;dog&quot;</tt>.</li>
<li>To expand your query to return whole sentences, use <tt>&lt;s/&gt; containing (...)</tt>. We don&#x2019;t yet support CWBs <tt>expand to</tt>, <tt>expand left to</tt>, etc., but may add this in the future.</li>
<li>The implication operator <tt>-&gt;</tt> is currently only supported in global constraints (expressions after the <tt>::</tt> operator), not in a regular token constraints. We may add this if there&#x2019;s demand for it.</li>
<li>We don&#x2019;t support the <tt>@</tt> anchor and corresponding <tt>target</tt> label; use a named anchor instead. If someone makes a good case for it, we will consider adding this feature.</li>
<li>backreferences to anchors only work in global constraints, so this doesn&#x2019;t work: <tt>A:[] [] [word = A.word]</tt>. Instead, use something like: <tt>A:[] [] B:[] :: A.word = B.word</tt>. We hope to add support for these in the near future, but our matching approach may not allow full support for this in all cases.</li>
</ul>
<p><a name="unsupported" id="unsupported"></a></p></div>
<div class="section">
<h3><a name="a.28Currently.29_unsupported_features"></a>(Currently) unsupported features</h3>
<p>The following features are not (yet) supported:</p>
<ul>

<li><tt>intersection</tt>, <tt>union</tt> and <tt>difference</tt> operators. These three operators will be added in the future. For now, the first two can be achieved using <tt>&amp;</tt> and <tt>|</tt> at the sequence level, e.g. <tt>&quot;double&quot; [] &amp; [] &quot;trouble&quot;</tt> to match the intersection of these queries, i.e. &#x201c;double trouble&#x201d; and <tt>&quot;happy&quot; &quot;dog&quot; | &quot;sad &quot;cat&quot;</tt> to match the union of &#x201c;happy dog&#x201d; and &#x201c;sad cat&#x201d;.</li>
<li><tt>_</tt> meaning &#x201c;the current token&#x201d; in token constraints. We will add this soon.</li>
<li><tt>lbound</tt>, <tt>rbound</tt> functions to get the edge of a region. We will probably add these.</li>
<li><tt>distance</tt>, <tt>distabs</tt> functions and <tt>match</tt>, <tt>matchend</tt> anchor points (sometimes used in global constraints). We will see about adding these.</li>
<li>using an XML element name to mean &#x2018;token is contained within&#x2019;, like <tt>[(pos = &quot;N&quot;) &amp; !np]</tt> meaning &#x201c;noun NOT inside in an  tag&#x201d;. We will see about adding these.</li>
<li>a number of less well-known features. If people ask, we will consider adding them.</li>
</ul>
<p><a name="using-cql" id="using-cql"></a></p></div></div>
<div class="section">
<h2><a name="Using_Corpus_Query_Language"></a>Using Corpus Query Language</h2>
<p><a name="matching-tokens" id="matching-tokens"></a></p>
<div class="section">
<h3><a name="Matching_tokens"></a>Matching tokens</h3>
<p>Corpus Query Language is a way to specify a &#x201c;pattern&#x201d; of tokens (i.e. words) you&#x2019;re looking for. A simple pattern is this one:</p>

<div>
<div>
<pre class="source">[word=&quot;man&quot;]
</pre></div></div>

<p>This simply searches for all occurrences of the word &#x201c;man&#x201d;. If your corpus includes the per-word properties lemma (i.e. headword) and pos (part-of-speech, i.e. noun, verb, etc.), you can query those as well. For example, to find a form of word &#x201c;search&#x201d; used as a noun, use this query:</p>

<div>
<div>
<pre class="source">[lemma=&quot;search&quot; &amp; pos=&quot;NOU&quot;]
</pre></div></div>

<p>This query would match &#x201c;search&#x201d; and &#x201c;searches&#x201d; where used as a noun. (Of course, your data may contain slightly different part-of-speech tags.)</p>
<p>The first query could be written even simpler without brackets, because &#x201c;word&#x201d; is the default property:</p>

<div>
<div>
<pre class="source">&quot;man&quot;
</pre></div></div>

<p>You can use the &#x201c;does not equal&#x201d; operator (!=) to search for all words except nouns:</p>

<div>
<div>
<pre class="source">[pos != &quot;NOU&quot;]
</pre></div></div>

<p>The strings between quotes can also contain wildcards, of sorts. To be precise, they are <a class="externalLink" href="http://en.wikipedia.org/wiki/Regular_expression">regular expressions</a>, which provide a flexible way of matching strings of text. For example, to find &#x201c;man&#x201d; or &#x201c;woman&#x201d;, use:</p>

<div>
<div>
<pre class="source">&quot;(wo)?man&quot;
</pre></div></div>

<p>And to find lemmata starting with &#x201c;under&#x201d;, use:</p>

<div>
<div>
<pre class="source">[lemma=&quot;under.\*&quot;]
</pre></div></div>

<p>Explaining regular expression syntax is beyond the scope of this document, but for a complete overview, see <a class="externalLink" href="http://www.regular-expressions.info/">regular-expressions.info</a>.</p>
<p><a name="sequences" id="sequences"></a></p></div>
<div class="section">
<h3><a name="Sequences"></a>Sequences</h3>
<p>Corpus Query Language allows you to search for sequences of words as well (i.e. phrase searches, but with many more possibilities). To search for the phrase &#x201c;the tall man&#x201d;, use this query:</p>

<div>
<div>
<pre class="source">&quot;the&quot; &quot;tall&quot; &quot;man&quot;
</pre></div></div>

<p>It might seem a bit clunky to separately quote each word, but this allow us the flexibility to specify exactly what kinds of words we&#x2019;re looking for. For example, if you want to know all single adjectives used with man (not just &#x201c;tall&#x201d;), use this:</p>

<div>
<div>
<pre class="source">&quot;an?|the&quot; [pos=&quot;ADJ&quot;] &quot;man&quot;
</pre></div></div>

<p>This would also match &#x201c;a wise man&#x201d;, &#x201c;an important man&#x201d;, &#x201c;the foolish man&#x201d;, etc.</p>
<p><a name="regex-operators-tokens" id="regex-operators-tokens"></a></p></div>
<div class="section">
<h3><a name="Regular_expression_operators_on_tokens"></a>Regular expression operators on tokens</h3>
<p>Corpus Query Language really starts to shine when you use the regular expression operators on whole tokens as well. If we want to see not just single adjectives applied to &#x201c;man&#x201d;, but multiple as well:</p>

<div>
<div>
<pre class="source">&quot;an?|the&quot; [pos=&quot;ADJ&quot;]+ &quot;man&quot;
</pre></div></div>

<p>This query matches &#x201c;a little green man&#x201d;, for example. The plus sign after [pos=&#x201c;ADJ&#x201d;] says that the preceding part should occur one or more times (similarly, * means &#x201c;zero or more times&#x201d;, and ? means &#x201c;zero or one time&#x201d;).</p>
<p>If you only want matches with two or three adjectives, you can specify that too:</p>

<div>
<div>
<pre class="source">&quot;an?|the&quot; [pos=&quot;ADJ&quot;]{2,3} &quot;man&quot;
</pre></div></div>

<p>Or, for two or more adjectives:</p>

<div>
<div>
<pre class="source">&quot;an?|the&quot; [pos=&quot;ADJ&quot;]{2,} &quot;man&quot;
</pre></div></div>

<p>You can group sequences of tokens with parentheses and apply operators to the whole group as well. To search for a sequence of nouns, each optionally preceded by an article:</p>

<div>
<div>
<pre class="source">(&quot;an?|the&quot;? [pos=&quot;NOU&quot;])+
</pre></div></div>

<p>This would, for example, match the well-known palindrome &#x201c;a man, a plan, a canal: Panama!&#x201d; (A note about punctuation: in BlackLab, punctuation tends to not be indexed as a separate token, but as a property of a word token - CWB and Sketch Engine on the other hand tend to index punctuation as a separate token instead. You certainly could choose to index punctuation as a separate token in BlackLab, by the way &#x2013; it&#x2019;s just not commonly done. Both approaches have their advantages and disadvantages, and of course the choice affects how you write your queries.)</p>
<p><a name="case-diacritics-sensitivity" id="case-diacritics-sensitivity"></a></p></div>
<div class="section">
<h3><a name="Case-_and_diacritics_sensitivity"></a>Case- and diacritics sensitivity</h3>
<p>CWB and Sketch Engine both default to (case- and diacritics) sensitive search. That is, they exactly match upper- and lowercase letters in your query, plus any accented letters in the query as well. BlackLab, on the contrary, defaults to *IN*sensitive search (although this default can be changed if you like). To match a pattern sensitively, prefix it with &#x201c;(?-i)&#x201d;:</p>

<div>
<div>
<pre class="source">&quot;(?-i)Panama&quot;
</pre></div></div>

<p>If you&#x2019;ve changed the default search to sensitive, but you wish to match a pattern in your query insensitively, prefix it with &#x201c;(?i)&#x201d;:</p>

<div>
<div>
<pre class="source">[pos=&quot;(?i)nou&quot;]
</pre></div></div>

<p>Although BlackLab is capable of setting case- and diacritics-sensitivity separately, it is not yet possible from Corpus Query Language. We may add this capability if requested.</p>
<p><a name="matching-xml-elements" id="matching-xml-elements"></a></p></div>
<div class="section">
<h3><a name="Matching_XML_elements"></a>Matching XML elements</h3>
<p>Corpus Query Language allows you to find text in relation to XML elements that occur in it. For example, if your data contains sentence tags, you could look for sentences starting with &#x201c;the&#x201d;:</p>

<div>
<div>
<pre class="source">&lt;s&gt;&quot;the&quot;
</pre></div></div>

<p>Similarly, to find sentences ending in &#x201c;that&#x201d;, you would use:</p>

<div>
<div>
<pre class="source">&quot;that&quot;&lt;/s&gt;
</pre></div></div>

<p>You can also search for words occurring inside a specific element. Say you&#x2019;ve run named entity recognition on your data and all person names are surrounded with &lt;person&gt;&#x2026;&lt;/person&gt; tags. To find the word &#x201c;baker&#x201d; as part of a person&#x2019;s name, use:</p>

<div>
<div>
<pre class="source">&quot;baker&quot; within &lt;person/&gt;
</pre></div></div>

<p>Note that forward slash at the end of the tag. This way of referring to the element means &#x201c;the whole element&#x201d;. Compare to &lt;person&gt;, which means &#x201c;the element&#x2019;s open tag&#x201d;, and &lt;/person&gt;, which means &#x201c;the element&#x2019;s close tag&#x201d;.</p>
<p>The above query will just match the word &#x201c;baker&#x201d; as part of a person&#x2019;s name. But you&#x2019;re likely more interested in the entire name that contains the word &#x201c;baker&#x201d;. So, to find those full names, use:</p>

<div>
<div>
<pre class="source">&lt;person/&gt; containing &quot;baker&quot;
</pre></div></div>

<p>Or, if you simply want to find all persons, use:</p>

<div>
<div>
<pre class="source">&lt;person/&gt;
</pre></div></div>

<p>As you can see, the XML element reference is just another query that yields a number of matches. So as you might have guessed, you can use &#x201c;within&#x201d; and &#x201c;containing&#x201d; with any other query as well. For example:</p>

<div>
<div>
<pre class="source">([pos=&quot;ADJ&quot;]+ containing &quot;tall&quot;) &quot;man&quot;
</pre></div></div>

<p>will find adjectives applied to man, where one of those adjectives is &#x201c;tall&#x201d;.</p>
<p><a name="label-tokens-capturing-groups" id="label-tokens-capturing-groups"></a></p></div>
<div class="section">
<h3><a name="Labeling_tokens.2C_capturing_groups"></a>Labeling tokens, capturing groups</h3>
<p>Just like in regular expressions, it is possible to &#x201c;capture&#x201d; part of the match for your query in a &#x201c;group&#x201d;.</p>
<p>CWB and Sketch Engine offer similar functionality, but instead of capturing part of the query, they label a single token. BlackLab&#x2019;s functionality is very similar but can capture a number of tokens as well.</p>
<p>Example:</p>

<div>
<div>
<pre class="source">&quot;an?|the&quot; Adjectives:[pos=&quot;ADJ&quot;]+ &quot;man&quot;
</pre></div></div>

<p>This will capture the adjectives found for each match in a captured group named &#x201c;Adjectives&#x201d;. BlackLab also supports numbered groups:</p>

<div>
<div>
<pre class="source">&quot;an?|the&quot; 1:[pos=&quot;ADJ&quot;]+ &quot;man&quot;
</pre></div></div>

<p><a name="global-constraints" id="global-constraints"></a></p></div>
<div class="section">
<h3><a name="Global_constraints"></a>Global constraints</h3>
<p>If you tag certain tokens with labels, you can also apply &#x201c;global constraints&#x201d; on these tokens. This is a way of relating different tokens to one another, for example requiring that they correspond to the same word:</p>

<div>
<div>
<pre class="source">A:[] &quot;by&quot; B:[] :: A.word = B.word
</pre></div></div>

<p>This would match &#x201c;day by day&#x201d;, &#x201c;step by step&#x201d;, etc.</p></div></div>
        </div>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &copy;2022
<a href="https://www.ivdnt.org/">Instituut voor Nederlandse Taal (INT)</a>.
All rights reserved.</p>
        </div>
      </div>
    </footer>
  </body>
</html>
